<!DOCTYPE html>
<html lang="en">
<head>
    <title>Animation Viewer</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            color: #ddd;
            font-family:Monospace;
            font-size:13px;
            text-align:center;

            background-color: #000;
            margin: 0;
            overflow: hidden;
        }

        h1
        {
            background-color: rgba(120,120,120,0.8);
        }

        #boneListing{
            position: absolute;
            float:right;
            background-color: rgba(54, 54, 85, 0.4);
            min-width: 200px;
            min-height: 500px;
            top: 90px;
            right: 10px;
            padding: 12px;
            margin: 5px;
            text-align: right;
        }


        #animationPanel{
            position: absolute;
            float:left;
            background-color: rgba(54, 54, 85, 0.4);
            min-width: 200px;
            min-height: 110px;
            top: 90px;
            left: 10px;
            padding: 12px;
            margin: 5px;
            text-align: right;
        }

        #texturePanel{
            position: absolute;
            float:left;
            background-color: rgba(54, 54, 85, 0.4);
            width: 258px;
            height: 300px;
            top: 280px;
            left: 10px;
            padding: 12px;
            margin: 5px;
            text-align: right;
        }

        #info {
            position: absolute;
            top: 0; width: 50%;
            padding: 5px;
            left: 25%;
        }
        a {
            color: #f00;
        }
    </style>
</head>
<body>
<div id="info"><h1>Animation Viewer</h1><a href="http://blacktowerentertainment.com">Black Tower Entertainment</a><br><b>Drag .js animation files, and textures onto this screen</b></div>
<div id="container"></div>
<div id="boneListing"><b style="text-align: left">Bone Attachments</b><hr><br><div id="bonePanel"></div>
    <button onclick="editor.toggleBoneVisibility()">DebugInfo</button>
    <button onclick="editor.toggleAnimation()">Animation</button>
    <button onclick="editor.toggleWireframe()">Wireframe</button>
    <button onclick="editor.stepAnimation()">Step</button>
</div>
<div id="animationPanel">
    <b style="text-align: left">Animation</b><hr>
    Active Animation: <div id="animationPanelContent">
    [UNLOADED]Please drop a .js animated file
    </div>
    Animation Speed:
    <select id="speedSelect">
        <option name=".25">(.125)x</option>
        <option name=".25">(.25)x</option>
        <option name=".33">(.33x)</option>
        <option name=".5">(.5x)</option>
        <option name="1" selected="selected">(1x)</option>
        <option name="2">(2x)</option>
        <option name="3">(4x)</option>
        <option name="4">(8x)</option>
    </select>
</div>
<div id="texturePanel">
    <b style="text-align: left">Texture</b><hr>
    <div id="textureDiv">
        <img width="256px" height="256px" id="textureImage">
        Drag image here to load
    </div>
</div>
<script src="js/libs/three.min.js"></script>
<script src="js/libs/stats.min.js"></script>
<script src="js/libs/OrbitControls.js"></script>
<script>
    var animationSpeed = 1.0;
    var container, stats, scene, renderer;
    var animation, selectAnimNode, texture;
    var clock = new THREE.Clock();
    editor = {};
    animating = true;
    init();
    document.getElementById("speedSelect").onchange = function(event)
    {
        animationSpeed = parseFloat(event.target.selectedOptions[0].attributes[0].nodeValue);
    };

    function PlayAnimation(name)
    {
        if(!name && name == "")
            return;
        if(animation)
            animation.stop();
        var mesh = editor.mesh;
        if(!mesh)
            return;
        animation = new THREE.Animation(
                editor.mesh,
                name);
        animation.play();
    }

    function GenerateAnimationMenu(mesh)
    {
        if(!mesh.geometry.animations && !mesh.geometry.animation)
            return;
        var rootNode = document.getElementById("animationPanelContent");
        rootNode.innerHTML = "";
        selectAnimNode = document.createElement("select");
        if(mesh.geometry.animations)
        {
            var length = mesh.geometry.animations.length;
            for(var i = 0; i < length; ++i)
            {
                var animation = mesh.geometry.animations[i];
                var name = animation.name;

                //Create dom option with <option value=i>name</option>
                var node = document.createElement("option");
                node.name = i;
                node.innerHTML = name;
                selectAnimNode.appendChild(node);
            }

        }
        else
        {
            node = document.createElement("option");
            node.name = 0;
            node.innerHTML = mesh.geometry.animation.name;
            selectAnimNode.appendChild(node);
        }
        selectAnimNode.onchange = function(event)
        {
            PlayAnimation(event.target.selectedOptions[0].innerHTML);
        };
        rootNode.appendChild(selectAnimNode);
    }

    function GenerateBoneListing(bones)
    {
        if(!bones)
            return;
        var rootNode = document.getElementById("bonePanel");
        rootNode.innerHTML = "";
        var length = bones.length;
        for(var i = 0; i < length; ++i)
        {
            var bone = bones[i].userData;
            var boneNode = document.createElement("div");
            boneNode.appendChild(document.createTextNode("["+bone.name + "]"));
            var button = document.createElement("input");
            button.type = "file";
            button.name = i;
            button.addEventListener("change", function(event)
            {
                //Add file to bone node
                if(event.target.files[0])
                {
                    var file = event.target.files[0];
                    loadFile(file, bones[event.target.name]);
                }
            });
            boneNode.appendChild(button);
            rootNode.appendChild(boneNode);
        }
    }

    function init() {
        container = document.getElementById( 'container' );
        editor.camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 10000 );
        editor.camera.position.set( 0, 105, 450 );
        editor.camera.lookAt(new THREE.Vector3());
        editor.scene = new THREE.Scene();
        editor.scene.fog = new THREE.FogExp2( 0x333333, 0.0003 );
        editor.boneScene = new THREE.Scene();
        scene = editor.scene;
        var dirLight = new THREE.DirectionalLight( 0xffffff,.6 );
        dirLight.position.set( 40, -4, -4 ).normalize();
        scene.add( dirLight );
        var light = new THREE.AmbientLight( 0xffffff,.4 );
        scene.add( light );
        editor.boneScene.add( light );
        renderer = new THREE.WebGLRenderer( { antialias: true } );

        renderer.setClearColor( scene.fog.color, 1 );
        renderer.setSize( window.innerWidth, window.innerHeight );
        renderer.sortObjects = true;
        renderer.domElement.tabIndex = 0;
        orbitControls = new THREE.OrbitControls(editor.camera, renderer.domElement);
        this.gridHalfSize = 320;
        this.gridSubDivisions = 32;
        this.gridHeight = 5;
        this.grid = new THREE.GridHelper(this.gridHalfSize, this.gridSubDivisions);
        this.grid.setColors(new THREE.Color("rgb(90,90,90)"), new THREE.Color("rgb(140,150,150)"));
        this.scene.add(this.grid);
        container.appendChild( renderer.domElement );

        stats = new Stats();
        stats.domElement.style.position = 'absolute';
        stats.domElement.style.top = '0px';
        container.appendChild( stats.domElement );

        window.addEventListener( 'resize', onWindowResize, false );
        animate();
    }

    function reset()
    {
        editor.camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 10000 );

    }

    function onWindowResize() {
        if(this.editor)
        {
            editor.camera.aspect = window.innerWidth / window.innerHeight;
            editor.camera.updateProjectionMatrix();
            renderer.setSize( window.innerWidth, window.innerHeight );
        }
    }

    function update()
    {

        var delta = clock.getDelta();
        if(animating)
            THREE.AnimationHandler.update( delta * animationSpeed );
        stats.update();
        orbitControls.update();
        if(this.editor !== undefined)
        {
            var rotationMatrix = new THREE.Matrix4();

            if(this.editor.bones)
            {
                var numBones = this.editor.bones.length;
                for(var j = 0; j < numBones; ++j)
                {
                    var bone = this.editor.bones[j];
                    var skinMatrix = (this.editor.mesh.bones[j].skinMatrix);
                    rotationMatrix.extractRotation(skinMatrix);
                    bone.position.setFromMatrixPosition(skinMatrix);
                    bone.rotation.setFromRotationMatrix(rotationMatrix);
                    bone.scale.setFromMatrixScale(skinMatrix);
                    var boneConnectionLength = bone.children.length-1;
                    for(var i = 0; i < boneConnectionLength; ++i)
                    {
                        var child = this.editor.mesh.bones[j].children[i];
                        var childHelper = bone.children[i+1];
                        childHelper.setLength(child.position.length());
                        childHelper.setDirection(new THREE.Vector3(child.position.x,child.position.y,child.position.z).normalize());
                    }
                }

                var numAttachedObjects = this.editor.attachedObjects.length;
                for(j = 0; j < numAttachedObjects; ++j)
                {
                    var object = this.editor.attachedObjects[j];
                    object.position = object.userData.position;
                    object.rotation = object.userData.rotation;
                    object.scale = object.userData.scale;
                }
            }

        }
    }

    function animate() {
        requestAnimationFrame( animate, renderer.domElement );
        update();
        if(this.editor)
        {
            renderer.clear(true, true, true);
            renderer.autoClear = false;
            renderer.render( scene, this.editor.camera );
            renderer.clear(false, true, true);
            renderer.render( this.editor.boneScene, this.editor.camera );
        }
        renderer.autoClear = true;
    }

editor.setScene = function( scene )
{
    this.scene = scene;
};

AddAnimationsToHandler = function(geometry)
{
    if(geometry.animation)
    {
        THREE.AnimationHandler.add(geometry.animation);
    }
    else if(geometry.animations)
    {
        var length = geometry.animations.length;
        for(var i = 0; i < length; ++i)
        {
            THREE.AnimationHandler.add(geometry.animations[i]);
        }
    }
};

editor.instanceMesh = function(geometry, parentParam)
{
    var numBones, j, normalMat, mesh;
    if(this.mesh && !parentParam)
    {
        this.scene.remove(this.mesh);
        if(this.mesh.bones)
        {
            numBones = this.mesh.bones.length;
            for(j = 0; j < numBones; ++j)
            {
                this.boneScene.remove(this.bones[j]);
            }

            var numAttachedObjects = this.attachedObjects.length;
            for(j = 0; j < numAttachedObjects; ++j)
            {
                this.scene.remove(this.attachedObjects[j]);
                this.attachedObjects = [];
            }
        }
        this.bones = [];
    }
    if(geometry)
    {
        geometry.buffersNeedUpdate = true;
        geometry.uvsNeedUpdate = true;
        if (geometry.animation || geometry.animations) {
            AddAnimationsToHandler(geometry);
            normalMat = new THREE.MeshLambertMaterial({ emissive: 0xCCCCCC, skinning : true, shininess : 0.36, Specular: 0x595959});
            if(texture)
                normalMat.map = texture;
            mesh = new THREE.SkinnedMesh(geometry, normalMat, false);
            if(!parentParam)
            {
                numBones = mesh.bones.length;
                this.bones = [];
                this.attachedObjects = [];
                for(j = 0; j < numBones; ++j)
                {
                    var bone = mesh.bones[j];
                    var sphereGeometry = new THREE.SphereGeometry(0.5);
                    var boneMeshDebug = new THREE.Mesh(sphereGeometry, new THREE.MeshNormalMaterial());
                    boneMeshDebug.material.wireframe = true;
                    boneMeshDebug.position.copy(new THREE.Vector3().applyMatrix4(bone.skinMatrix));
                    this.boneScene.add(boneMeshDebug);
                    //Add transform helper
                    var axisHelper = new THREE.AxisHelper( 7 );
                    boneMeshDebug.add(axisHelper);

                    var childLen = bone.children.length;
                    for(var i = 0; i < childLen; ++i)
                    {
                        var child = bone.children[i];
                        var lineLength = child.position.length();
                        var arrowHelper = new THREE.ArrowHelper(child.position, new THREE.Vector3(), lineLength, 0xDD00AA);
                        boneMeshDebug.add(arrowHelper);
                        arrowHelper.name = child.name;
                    }

                    boneMeshDebug.userData = mesh.bones[j];
                    this.bones[j] = boneMeshDebug;
                }
                GenerateBoneListing(this.bones);
                GenerateAnimationMenu(mesh);
                this.geometry = geometry;
                this.bonesVisible = true;
            }
        }
        else
        {
            normalMat = new THREE.MeshLambertMaterial({ emissive: 0xCCCCCC, shininess : 0.36, Specular: 0x595959});
            if(this.mesh && this.mesh.material.map)
                normalMat.map = this.mesh.material.map;
            mesh = new THREE.Mesh(geometry, normalMat, false);
        }
    }
    if(editor.camera && !parentParam)
    {
        if(mesh && mesh.geometry)
        {
            mesh.geometry.computeBoundingSphere();
            editor.camera.lookAt(mesh.geometry.boundingSphere.center);
            orbitControls.target = mesh.geometry.boundingSphere.center;
        }
    }
    if(parentParam)
    {
        mesh.userData = parentParam;
        this.attachedObjects.push(mesh);
        this.scene.add(mesh);
    }
    else
    {
        this.scene.add(mesh);
        this.mesh = mesh;
    }
    if(selectAnimNode)
        if(selectAnimNode.children.length > 0)
            PlayAnimation(selectAnimNode.children[0].innerHTML);
};

editor.toggleAnimation = function()
{
    if(!this.bones)
        return;
    animating = !animating;
};

editor.stepAnimation = function()
{
    if(!animating)
        THREE.AnimationHandler.update( 1/30 );
};

editor.toggleBoneVisibility = function()
{
    if(!this.bones)
        return;
    this.bonesVisible = !this.bonesVisible;
    var visibility = this.bonesVisible;
    var length = this.mesh.bones.length;
    for(var j = 0; j < length; ++j)
    {
        this.bones[j].visible = visibility;
        this.bones[j].traverse(function(object)
        {
            object.visible = visibility;
        });
    }
};

editor.toggleWireframe = function()
{
    if(this.mesh)
    {
        var wireframe = !this.mesh.material.wireframe;
        this.mesh.material.wireframe = !wireframe;
        this.mesh.traverse(function(object)
        {
           if(object.material)
                object.material.wireframe = wireframe;
        });
    }
}

editor.addObject = function( object, parentParam)
{
    this.instanceMesh(object.geometry, parentParam);
};

this.loadFile = function (file, parentParam)
{
    if(!file)
        return;
    var filename = file.name;
    var extension = filename.split( '.' ).pop().toLowerCase();

    switch ( extension ) {
        case 'jpg':
        case 'bmp':
        case 'gif':
        case 'dds':
        case 'mp4':
        case 'png':
            var reader = new FileReader();
            reader.addEventListener( 'load', function ( event ) {

                    newTexture = new THREE.ImageUtils.loadTexture(event.target.result, {}, function(newTexture)
                    {
                        img = document.getElementById("textureImage");

                        img.addEventListener( "load" , function()
                        {
                            editor.instanceMesh(editor.geometry);
                        });
                        texture = newTexture;
                        img.src = event.target.result;
                        img.style.width = 256;
                        img.style.width = 256;

                    });
            }, false );


            reader.readAsDataURL( file );


            break;
        case 'babylon':

            var reader = new FileReader();
            reader.addEventListener( 'load', function ( event ) {

                var contents = event.target.result;
                var json = JSON.parse( contents );

                var loader = new THREE.BabylonLoader();
                var scene = loader.parse( json );

                editor.setScene( scene );

            }, false );
            reader.readAsText( file );

            break;

        case 'ctm':

            var reader = new FileReader();
            reader.addEventListener( 'load', function ( event ) {

                var contents = event.target.result;

                var stream = new CTM.Stream( contents );
                stream.offset = 0;

                var loader = new THREE.CTMLoader();
                loader.createModelClassic( new CTM.File( stream ), function( geometry ) {

                    geometry.sourceType = "ctm";
                    geometry.sourceFile = file.name;

                    var material = new THREE.MeshPhongMaterial();

                    var mesh = new THREE.Mesh( geometry, material );
                    mesh.name = filename;

                    editor.addObject( mesh );

                } );

            }, false );
            reader.readAsBinaryString( file );

            break;

        case 'dae':

            var reader = new FileReader();
            reader.addEventListener( 'load', function ( event ) {

                var contents = event.target.result;

                var parser = new DOMParser();
                var xml = parser.parseFromString( contents, 'text/xml' );

                var loader = new THREE.ColladaLoader();
                loader.parse( xml, function ( collada ) {

                    collada.scene.name = filename;

                    editor.addObject( collada.scene, collada.skins);

                } );

            }, false );
            reader.readAsText( file );

            break;

        case 'js':
        case 'json':

        case '3geo':
        case '3mat':
        case '3obj':
        case '3scn':

            var reader = new FileReader();
            reader.addEventListener( 'load', function ( event ) {
                var contents = event.target.result;
                if ( contents.indexOf( 'postMessage' ) !== -1 ) {
                    var blob = new Blob( [ contents ], { type: 'text/javascript' } );
                    var url = URL.createObjectURL( blob );
                    var worker = new Worker( url );
                    worker.onmessage = function ( event ) {
                        event.data.metadata = { version: 2 };
                        handleJSON( event.data, file, filename, parentParam);
                    };

                    worker.postMessage( Date.now() );

                    return;

                }

                var data;

                try {

                    data = JSON.parse( contents );

                } catch ( error ) {

                    alert( error );
                    return;

                }

                handleJSON( data, file, filename, parentParam);

            }, false );
            reader.readAsText( file );

            break;

        case 'obj':

            var reader = new FileReader();
            reader.addEventListener( 'load', function ( event ) {

                var contents = event.target.result;

                var object = new THREE.OBJLoader().parse( contents );
                object.name = filename;

                editor.addObject( object );

            }, false );
            reader.readAsText( file );

            break;

        case 'ply':

            var reader = new FileReader();
            reader.addEventListener( 'load', function ( event ) {

                var contents = event.target.result;

                console.log( contents );

                var geometry = new THREE.PLYLoader().parse( contents );
                geometry.sourceType = "ply";
                geometry.sourceFile = file.name;

                var material = new THREE.MeshPhongMaterial();

                var mesh = new THREE.Mesh( geometry, material );
                mesh.name = filename;

                editor.addObject( mesh );

            }, false );
            reader.readAsText( file );

            break;

        case 'stl':

            var reader = new FileReader();
            reader.addEventListener( 'load', function ( event ) {

                var contents = event.target.result;

                var geometry = new THREE.STLLoader().parse( contents );
                geometry.sourceType = "stl";
                geometry.sourceFile = file.name;

                var material = new THREE.MeshPhongMaterial();

                var mesh = new THREE.Mesh( geometry, material );
                mesh.name = filename;

                editor.addObject( mesh, parentParam);

            }, false );

            if ( reader.readAsBinaryString !== undefined ) {

                reader.readAsBinaryString( file );

            } else {

                reader.readAsArrayBuffer( file );

            }

            break;

        /*
         case 'utf8':

         var reader = new FileReader();
         reader.addEventListener( 'load', function ( event ) {

         var contents = event.target.result;

         var geometry = new THREE.UTF8Loader().parse( contents );
         var material = new THREE.MeshLambertMaterial();

         var mesh = new THREE.Mesh( geometry, material );

         editor.addObject( mesh );

         }, false );
         reader.readAsBinaryString( file );

         break;
         */

        case 'vtk':

            var reader = new FileReader();
            reader.addEventListener( 'load', function ( event ) {

                var contents = event.target.result;

                var geometry = new THREE.VTKLoader().parse( contents );
                geometry.sourceType = "vtk";
                geometry.sourceFile = file.name;

                var material = new THREE.MeshPhongMaterial();

                var mesh = new THREE.Mesh( geometry, material );
                mesh.name = filename;

                editor.addObject( mesh, parentParam);

            }, false );
            reader.readAsText( file );

            break;

        case 'wrl':

            var reader = new FileReader();
            reader.addEventListener( 'load', function ( event ) {

                var contents = event.target.result;

                var result = new THREE.VRMLLoader().parse( contents );

                editor.setScene( result );

            }, false );
            reader.readAsText( file );

            break;

        default:

            alert( 'Unsupported file format.' );

            break;

    }

};

var handleJSON = function (data, file, filename, parentParam)
{

    if ( data.metadata === undefined ) { // 2.0

        data.metadata = { type: 'Geometry' };

    }

    if ( data.metadata.type === undefined ) { // 3.0

        data.metadata.type = 'Geometry';

    }

    if ( data.metadata.version === undefined ) {

        data.metadata.version = data.metadata.formatVersion;

    }

    if ( data.metadata.type.toLowerCase() === 'geometry' ) {

        var loader = new THREE.JSONLoader();
        var result = loader.parse( data );

        var geometry = result.geometry;
        var material = result.materials !== undefined
                ? new THREE.MeshFaceMaterial( result.materials )
                : new THREE.MeshPhongMaterial();

        geometry.sourceType = "ascii";
        geometry.sourceFile = file.name;

        var mesh = new THREE.Mesh( geometry, material );
        mesh.name = filename;

        editor.addObject( mesh, parentParam );

    } else if ( data.metadata.type.toLowerCase() === 'object' ) {

        var loader = new THREE.ObjectLoader();
        var result = loader.parse( data );

        if ( result instanceof THREE.Scene ) {

            editor.setScene( result );

        } else {

            editor.addObject( result, parentParam );

        }

    } else if ( data.metadata.type.toLowerCase() === 'scene' ) {

        // DEPRECATED

        var loader = new THREE.SceneLoader();
        loader.parse( data, function ( result ) {

            editor.setScene( result.scene );

        }, '' );

    }

};

document.addEventListener('dragover', function (event)
{
    event.preventDefault();
    event.dataTransfer.dropEffect = 'copy';
}, false);

document.addEventListener('drop', function (event)
{
    event.preventDefault();
    loadFile( event.dataTransfer.files[ 0 ] );
}, false );


</script>

</body>
</html>

